#!/usr/bin/perl

use strict;
use warnings;

die "Usage: $0 index raw-html >clean-html\n"
   unless @ARGV==2;
my ($index, $html) = @ARGV;

my %external_modules = map { ($_ => 1) }
 qw/Net::Config Net::Domain Net::SMTP IO::Server::INET Pod::HTML
    Mail::Internet MIME::Entity Text::Autoformat HTML::FormatText
    HTML::FormatPS Mail::Address MIME::Types MIME::Type
    Object::Realize::Later IO::File IO::Handle Tie::Array Inline::C
    Mail::Folder/;

my %index;
sub read_index($)
{   my $filename = shift;

    local $_;

    open INDEX, '<', $filename
        or die "Cannot open index $filename: $!\n";

    my ($manual, $pkg);

    while(<INDEX>)
    {   next if m!^\s*$!;

        if( m!^([\w:-]+)\s+([\w:-]+)\s*$! )
        {    ($manual, $pkg) = ($1, $2);
             $index{$manual} = {};
        }
        elsif( m!^(\w+)\(\S*\)\s+([\w:-]+)\s*$! ) { $index{$manual}{$1} = $2 }
        elsif( m!^(\w+)\(\S*\)\s*$! )             { $index{$manual}{$1} = undef }
        else
        {   warn "Illegal line $filename $.: $_";
        }
    }

    close INDEX;
}

sub rel_link($$)
{   my ($from, $to) = @_;
    return '' if $from eq $to;

    my @from = split /\:\:/, $from;
    my @to   = split /\:\:/, $to;
    pop @from;

    while(@from && @to && $from[0] eq $to[0])
    {   shift @from;
        shift @to;
    }

    ('../' x @from) . (join '/', @to) . '.html';
}

read_index $index;
(my $manual = $html) =~ s!/!::!g;
$manual =~ s/\.html$//;

warn "Unknown manual $manual"
   unless exists $index{$manual};

open HTML, '<', $html
   or die "Cannot read html from $html: $!\n";

my @levels= split /\:\:/, $manual;
my $depth = @levels-1;
my $css   = qq(<link rel=stylesheet type="text/css" href="). ('../' x $depth)
          . qq(pod.css">);

while(<HTML>)                # Header
{    if( m#\</head\># )
     {   print "$css\n$_";
         last;
     }

     print;
}

my $insert_pre = 0;
while(<HTML>)                # Body
{
     chomp;
     s#^\<li .*\<p\>(.*?)\<.*#<li class=POD_ITEM>$1#;
     s#^\<dt .*?"\>\<b\>(.*?)\</a\>#<dt class=POD_ITEM><b>$1#;
     $insert_pre = 1 if s#^\<pre class#<p class#;
 
     if( $insert_pre && m!^\s*$! )  # bug in mpod2html: pre too early
     {    $_ = "<pre>";
          $insert_pre = 0;
     }

     my $in_example = m/^\s/;

     my @line
        = $in_example
        ? split / ( [\w-]+\:\:[\w:-]*\w\b ) /x
        : split / ( [\w]+\:\:[\w:-]*\(\w*\)
                  | [\w-]+\:\:[\w:-]*\w\b
                  | [\w\:-]+\(\w*\)
                  )
                /x;

     if(@line==1)
     {   print "$_\n";
         next;
     }

     for(my $i=1; $i<@line; $i+=2)
     {   my $ref = $line[$i];
         my ($text, $method, $option)
          = $ref =~ m/\:\:(\w+)\((\w*)\)$/ ? ($`, $1, $2)
          : $ref =~ m/^(\w+)\((\w*)\)$/    ? ($manual, $1, $2)
          :                                  ($ref, '', '');

         my $pkg = $text;
         $pkg =~ s/^MM\:\:/Mail::Message::/;
         $pkg =~ s/^MB\:\:/Mail::Box::/;

         if(!exists $index{$pkg})
         {   warn "WARNING $html $.: ref to unknown package $pkg.\n"
                unless exists $external_modules{$pkg};

             next;
         }

         $pkg     = $index{$pkg}{"$method($option)"} || $pkg;
         my $link = rel_link $manual, $pkg;

         my $replace
          = $pkg ne $manual ? qq(<a href="$link" class=manual>$text</a>)
          : length  $method ? ''
          :                   qq(<span class="myself">$text</span>);

         $replace .= qq( method <a href="$link#$method">$method</a>)
             if length $method;

         $replace .= qq( option <a href="$link#${method}($option)">$option</a>)
             if length $option;

         $line[$i] = $replace;
     }

     print @line,"\n";
}

close HTML;
