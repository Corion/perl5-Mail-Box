#!/usr/bin/perl5.8.0

# Create a distribution:
#   extracts meta-pod from pm
#   converts meta-pod to real pods
#   converts meta-pod to html

use warnings;
use strict;

use IO::File;
use File::Spec;
use File::Basename;
use File::Copy;
use List::Util 'first';

use lib '.';

die "Usage: $0 tmpdir version [verbose]"
   unless @ARGV >= 2 && @ARGV <= 3;

my ($workdir, $version, $verbose) = @ARGV;

my $markov         = [ "Mark Overmeer" => 'mark@overmeer.net'      ];
my $liz            = [ "Liz Mattijsen" => 'liz@dijkmat.nl'         ];
my $greg           = [ "Greg Matheson" => 'lang@ms.chinmin.edu.tw' ];

my $website        = 'http://perl.overmeer.net/mailbox/';
my $mailinglist    = 'mailbox@overmeer.net';
my $pod_index      = "$workdir/method-index";
my $html_root      = "/home/markov/shared/perl/public_html/mailbox/html";

my $url_root       = "/mailbox";
my $url_coderoot   = "$url_root/source";
my $url_htmlroot   = "$url_root/html";
my $url_css        = "$html_root/mailbox.css";

my $url_cpansearch = "http://search.cpan.org";
my $url_modsearch  = "$url_cpansearch/perldoc?";

my %pkgs;    # pods organized by package => [ manuals ]
my %pods;    # pods by           name => manual
my %methods;

my @method_sections =
 ( # For all packages
   'Initiation'

   # Mail::Box
 , 'Opening folders'
 , 'On open folders'
 , 'Closing the folder'
 , 'The messages'
 , 'Sub-folders'
 , 'Message threads [internals]'

   # Mail::Box::Tie
 , 'Tied Interface'

   # Mail::Message
 , 'Constructing a Message'
 , 'The Message'
 , 'The Header'
 , 'Header Shortcuts'
 , 'The Body'
 , 'Access to the Message'
 , 'Labels'

   # Mail::Box::Locker
 , 'The Locker'
 , 'Locking'

   # Mail::Message::TransferEnc
 , 'The Encoder'
 , 'Encoding'

   # Mail::Message::Body
 , 'The Body'                   # Already defined
 , 'About the Payload'
 , 'Access to the Payload'
 , 'Constructing a Body'

   # Mail::Message::Head
 , 'The Header                   # Already defined'
 , 'Constructing a Header'
 , 'Access to the Header'

   # Mail::Message::Field
 , 'The Field'
 , 'Access to the Field'

   # Mail::Box::MH::Index
 , 'The Index'

   # Mail::Box::MH::Labels
 , 'The Label Table'

   # Mail::Box::Manager
 , 'Manage Folders'
 , 'Move Messages to Folders'
 , 'Manage Threads'

   # Mail::Box::Thread::Manager
 , 'Grouping Folders'
 , 'The Threads'
 , 'Keeping Thread Information [internals]'

   # Mail::Box::Thread::Node
 , 'The Thread Node'
 , 'The Thread Order'
 , 'Whole Threads'

   # Mail::Message::Convert
 , 'Converting'

   # Mail::Transport
 , 'Server Connection'
 , 'Sending Mail'
 , 'Receiving Mail'
 , 'Exchanging Information'
 , 'Protocol [internals]'

   # Mail::Box::Search
 , 'Searching'
 , 'The Results'

   # Mail::Box::Parser
 , 'The Parser'
 , 'Parsing'

   # For all packages
 , 'Reading and Writing [internals]'
 , 'Logging and Tracing'
 , 'Other Methods'
 );

my %section_order;
foreach (@method_sections)
{    $section_order{$_} = keys %section_order
         unless exists $section_order{$_};
}

sub mkdirhier($)
{   my @dirs = File::Spec->splitdir(shift);
    my $path = shift @dirs;   #  '/'

    while(@dirs)
    {   $path = File::Spec->catdir($path, shift @dirs);
        die "Cannot create $path $!"
            unless -d $path || mkdir $path;
    }
}

# Read the MANIFEST file
sub manifest()
{   my $filename = 'MANIFEST';
    my $file = IO::File->new($filename, "r")
       or die "Cannot open $filename: $!\n";

    my @dist = $file->getlines;
    $file->close;

    chomp foreach @dist;
    @dist;
}

sub unique(@) { my %u = map { ($_ => 1) } @_; keys %u }

sub ordered_sections(@)
{   sort {$section_order{$a} <=> $section_order{$b}} @_;
}

sub filename_to_package($)
{   my $package = shift;
    $package =~ s#/#::#g;
    $package =~ s/\.(pm|pod)$//g;
    $package;
}
    
sub strip_pod($$)
{   my ($fromname, $toname) = @_;

    my $from = IO::File->new($fromname, "r")
        or die "Cannot read from $fromname: $!\n";

    my $to   = IO::File->new($toname, "w")
        or die "Cannot write to $toname: $!\n";

    print "Stripping $fromname into $toname.\n"
        if $verbose;

    my $in_pod     = 0;
    my $last_blank = 1;

    while(<$from>)
    {   warn "WARNING $fromname $.: '$1' within pod\n"
            if $in_pod && m!^(sub|my|our|package|use) !;

        if( m!^\=cut! ) { $in_pod = 0 }
        elsif( m!^\=! ) { $in_pod = 1 }
        elsif($in_pod)  { ; }
        elsif( m!^\#\-\-\-! ) { ; }
        elsif($last_blank && m!^\s*$!) { ; }
        else
        {   s/[ \t]+$//;
            $last_blank = $_ eq "\n";
            $to->print($_);

            $to->print("our \$VERSION = $version;  # Part of Mail::Box\n")
                 if m!^package\s!;
        }
    }

    $from->close;
    $to->close;
}

sub absorb_pod($)
{   my $filename = shift;

    my $file = IO::File->new($filename, "r")
        or die "Cannot read from $filename: $!\n";

    print "Absorbing POD of $filename: "
        if $verbose;

    my $pod  = {filename => $filename, chapters => []};

    my $in_pod = 0;
    my ($chapter, $section, $body);
    my ($nrchapter, $nrsection) = (0,0);

    while( <$file> )
    {
        if( m!^=cut! )
        {   $in_pod = 0;
            next;
        }

        if( ! m/^\=/ && ! $in_pod)
        {
            if( m!^\s*package\s+(.*?)\s*\;\s*$! )
            {   my $pkg = $1;
                warn "WARNING $filename $.: Second package statement\n"
                    if exists $pod->{package};

                $pod->{package} = $pkg;
            }

            next;
        }
        elsif( ! m/^\=/ )
        { 
            warn "WARNING $filename $.: POD outside head\n"
                unless defined $chapter;

            warn "WARNING $filename $.: Comment in pod\n"
                if m!^\#!;

            push @$body, $_;

            next;
        }

        $in_pod = 1;
        if( m!^\=head1\s+(.*?)\s*$! )
        {   $body  = [];
            $chapter = { title => $1, text => $body, sections => [] };
            push @{$pod->{chapters}}, $chapter;
            $nrchapter++;
        }
        elsif( m!^\=head2\s+(.*?)\s*$! && $chapter->{title} eq 'METHODS' )
        {   $body  = [];

            warn "ERROR $filename $.: Unknown section $1\n"
                unless exists $section_order{$1};

            $section = { title => $1, text => $body };
            push @{$chapter->{sections}}, $section;
            $nrsection++;
        }
        else
        {   push @$body, $_;
        }
    }

    unless($pod->{package})
    {   warn "WARNING $filename: No package found.\n"
            unless $filename =~ m/\.pod$/;

        my $package = $pod->{filename};
        $package    =~ s/\.\w+$//;
        $package    =~ s#/#::#g;
        $pod->{package} = $package;
    }

    $pod->{manual} = filename_to_package $pod->{filename};

    print " $nrchapter chapters\n"
        if $verbose;

    $pod;
}

sub dump_pkg_structure()
{
    foreach my $pod (map { @{$pkgs{$_}{pods}} } sort keys %pkgs)
    {   print "POD: $pod->{package}\n";
        print "   FILENAME: $pod->{filename}\n";
        print "   ISA: @{$pod->{isa}}\n";
        foreach my $chapter (@{$pod->{chapters}})
        {   print "   CHAPTER: $chapter->{title}\n";
            print "      TEXT: ", scalar @{$chapter->{text}}, " lines\n";
    
            foreach my $section (@{$chapter->{sections}})
            {   print "      SECTION: $section->{title}; "
                    , scalar @{$section->{text}}, " lines\n";
            }
        }
    }
}

sub get_compile_info($$)
{   my ($package, $filename) = @_;

    eval { require $filename };
    if($@)
    {   print "Cannot compile $filename: $@\n";
        return (isa => []);
    }

    no strict 'refs';
    my @isa = grep /^Mail\:\:/, @{"${package}::ISA"};

    my $realize;
    $realize = $package->willRealize
        if $package->can('willRealize');

    (isa => \@isa, realize => $realize);
}

sub cleanup_package_relations($)
{   my $package = shift;
    my $pkg = $pkgs{$package};

    my @isa = unique map { defined $_->{isa} ? @{$_->{isa}} : () } @{$pkg->{pods}};
    warn "WARNING $package: Multiple inheritance not supported.\n"
        if @isa > 1;

    if(my $isa = $isa[0])
    {   $pkg->{extends} = $isa;
        push @{$pkgs{$isa}{extended_by}}, $package;
        $pkgs{$isa}{pods} ||= [];    # require for newly created, external pkgs
    }

    my @real = unique map { defined $_->{realize} ? ($_->{realize}) : () }
        @{$pkg->{pods}};

    warn "WARNING $package: Only one realization possible.\n"
        if @real > 1;

    if(my $real = $real[0])
    {   $pkg->{realizes} = $real;
        push @{$pkgs{$real}{realized_by}}, $package;
    }

    $pkg->{abbrev}  = join '', map {substr $_, 0, 1}
        split m/\:\:/, $package;
}

sub extract_methods($$$);
sub build_method_index()
{   %methods = ();

    foreach my $pod (values %pods)
    {   my $manual = $pod->{manual};
        print "extraction methods from $manual.\n"
            if $verbose;

        foreach my $chapter ( @{$pod->{chapters}} )
        {   my $title = $chapter->{title};
            next unless $title eq 'METHODS';
            next unless $chapter->{sections};

            extract_methods $manual, $_->{title}, $_->{text}
                foreach @{$chapter->{sections}};
        }
    }
}

sub extract_methods($$$)
{   my ($manual, $section, $text) = @_;
    return unless defined $text && @$text;
#print "Got ".@$text." lines in $section\n";

    my (@description, $fill, $method);
    
    while(@$text)
    {   my $line = shift @$text;
        if( $line =~ m!^\=(c_|ci_|i_|no_)?method\s*(\w+)\s*(.*?)\s*$! )
        {   $method
               = { type    => ($1 || 'i_'), name => $2, usage   => $3
                 , manual  => $manual, section => $section
                 , descr   => '',      options => []
                 , default => []
                 };

            warn "new() always class method in $manual"
                if $2 eq 'new' && $1 ne 'c_';

            push @{$methods{$2}}, $method;
            $fill = \$method->{descr};
        }
        elsif( $line =~ m!^\=option\s*([\w-]+)\s*(.*?)\s*$! )
        {   my $option
              = { name    => $1,      usage   => $2
                , manual  => $manual, section => $section
                , descr   => ''
                };
            push @{$method->{options}}, $option;
            $fill = \$option->{descr};
        }
        elsif( $line =~ m!^\=examples?! )
        {   $method->{examples} = '';
            $fill = \$method->{examples};
        }
        elsif( $line =~ m!^\=(error|warning)\s*([^\n]+)! )
        {   my $report = [ $1, $2, '' ];
            push @{$method->{reports}}, $report;
            $fill = \$report->[2];
        }
        elsif( $line =~ m!^\=default\s*([\w-]+)\s*(.*?)\s*$! )
        {   push @{$method->{defaults}}, {option => $1, value => $2} }
        elsif(defined $fill) { $$fill .= $line }
        else                 { push @description, $line }
    }

    @$text = @description;
}

sub make_text_html($$)
{   my ($filename, $text) = (shift, text_cleanup(shift));
    return '' unless defined $text;
   
    $text =~ s/\&/\&amp;/g;
    for($text)
    {   s#\&#\amp;#g;
        s#(?<![LFCIBE])\<#&lt;#g;
        s#\bL\<([^>]*)\>#<a href="$url_modsearch$1>$1</a>#g;
        s#\bF\<([^>]*)\>#<a href="$url_coderoot"/$1>$1</a>#g;
        s#\bC\<([^>]*)\>#<code>$1</code>#g;
        s#\bI\<([^>]*)\>#<em>$1</em>#g;
        s#\bB\<([^>]*)\>#<b>$1</b>#g;
        s#\bE\<([^>]*)\>#\&$1#g;
        s#\-\>#-\&gt;#g;
        s#\n*=over\s+\d+\s*#\n<ul>#gms;
        s#\n*\=item\s*(?:\*\s*)?([^\n]*)\s*#\n<li><b>$1</b><br />\n#gs;
        s#\n*\=back\s+#</ul>\n#gms;

        my ($label, $title);
        s#\=head2\s*([^\n]*)#
          $title = $1;
          $label = $title;
          $label =~ s/\W+/_/g;
          qq[<h3 class="subsection"><a name="$label">$title</a></h3>];
         #ge;

        s!(?:(?:^|\n)
              [^\ \t\n]+[^\n]*      # line starting with blank: para
          )+
         !<p>$&</p>!gsx;

        s!(?:(?:^|\n)               # start of line
              [\ \t]+[^\n]+         # line starting with blank: pre
          )+
         !<pre>$&\n</pre>!gsx;

        s#</pre>\n<pre>##gs;
        s#<p>\n#\n<p>#gs;

        s#\b[A-Z][\w-]*(?:\:\:[A-Z][\w-]*\w)+(?![\:\w])#
          href_to_pkg($filename, $&)#ge;
    }

    $text;
}

sub inheritance_to_pod($$)
{   my ($file, $package) = @_;
    my $pkg        = $pkgs{$package}
        or die "Unknown package $package.\n";

    my @subclasses = $pkg->{extended_by} ? @{$pkg->{extended_by}} : ();
    my $superclass = $pkg->{extends};

    my @realized   = $pkg->{realized_by} ? @{$pkg->{realized_by}} : ();
    my $realizes   = $pkg->{realizes};

    my @extras     = grep {$_->{manual} ne $_->{package}} @{$pkg->{pods}};

    return '' unless @subclasses || $realizes || $superclass || @realized
               || @extras;

    $file->print("\n=head1 CLASS INHERITANCE\n");

    if($realizes)
    {   $file->print("\n $package realizes a $realizes\n");
        $superclass = $pkgs{$realizes}{extends};
    }

    if(@extras)
    {   $file->print("\n $package has extra code in\n");
        $file->print("   $_->{manual}\n") foreach @extras;
    }

    $file->print("\n $package\n") if defined $superclass;
    while(defined $superclass)
    {   $file->print("   is a $superclass\n");
        $superclass = $pkgs{$superclass}{realizes}
           ? $pkgs{$superclass}{realizes}
           : $pkgs{$superclass}{extends};
    }

    if(@subclasses)
    {   $file->print("\n $package is extended by\n");
        $file->print("   $_\n") foreach sort @subclasses;
    }

    if(@realized)
    {   $file->print("\n $package is realized by\n");
        $file->print("   $_\n") foreach sort @realized;
    }
}

sub inheritance_to_html($$$)
{   my ($file, $filename, $package) = @_;
    my $pkg        = $pkgs{$package}
        or die "Unknown package $package.\n";

    my @subclasses = $pkg->{extended_by} ? @{$pkg->{extended_by}} : ();
    my $superclass = $pkg->{extends};

    my @realized   = $pkg->{realized_by} ? @{$pkg->{realized_by}} : ();
    my $realizes   = $pkg->{realizes};

    my @extras     = grep {$_->{manual} ne $_->{package}} @{$pkg->{pods}};

    return '' unless @subclasses || $realizes || $superclass || @realized
               || @extras;

    my $indent     = '&nbsp;' x 4;
    $file->print("<b>Class hierarchy:</b><br />\n");
    $file->print($package, "<br />\n");

    if($realizes)
    {   $file->print("realizes a ",href_to_pkg($filename, $realizes)," which<br />\n");
        $superclass= $pkgs{$realizes}{extends};
        $file->print("&nbsp;<br />\n");
    }

    while(defined $superclass)
    {   $file->print($indent, 'is a ', href_to_pkg($filename, $superclass), "<br />\n");
        $superclass = $pkgs{$superclass}{realizes}
           ? $pkgs{$superclass}{realizes}
           : $pkgs{$superclass}{extends};
    }
    $file->print("&nbsp;<br />\n");

    if(@extras)
    {   $file->print("has extra code in<br />\n");
        $file->print("$indent$_->{manual}<br />\n")
            foreach @extras;
        $file->print("&nbsp;<br />\n");
    }

    if(@subclasses)
    {   $file->print("is extended by<br />\n");
        $file->print($indent, href_to_pkg($filename, $_), "<br />\n")
            foreach sort @subclasses;
        $file->print("&nbsp;<br />\n");
    }

    if(@realized)
    {   $file->print("is realized by<br />\n");
        $file->print($indent, href_to_pkg($filename, $_), "<br />\n")
            foreach sort @realized;
        $file->print("&nbsp;<br />\n");
    }
}

# remove superfluous blank lines etc.  Returns scalar
sub text_cleanup($)
{   my $text = shift;
    return '' unless defined $text;

    if(ref $text)
    {   shift @$text while @$text && $text->[0]  =~ m!^\s*$!;
        pop   @$text while @$text && $text->[-1] =~ m!^\s*$!;
        return @$text ? join('', @$text) : '';
    }

    $text =~ s/^([ \t]*\n)+//;
    $text =~ s/([ \t]*\n)+$/\n/;
    length($text) ? "\n$text" : '';
}

sub make_text_pod($)
{   my $text = text_cleanup(shift);

    1 while $text =~ s#\bL\<([^>]*)\>#L<$1|$1>#g;

    $text;
}

sub link_to($$)
{   my ($here, $absolute) = @_;

    # Convert absolute link to relative
    my @from     = split m[/], $here;
    my @to       = split m[/], $absolute;

    while(@from && @to && $from[0] eq $to[0])
    {   shift @from; shift @to }

    return "" if @from==0 && @to==0;   # same file
    pop @from;                         # filename
    join '/', ('..') x @from, @to;
}

sub href_to_pkg($$)
{   my ($here,$package) = @_;

    my $link = defined $pods{$package}
             ? link_to($here, "$pods{$package}{htmldir}/index.html")
             : "$url_modsearch$package";

    qq[<a href="$link" target="_top">$package</a>];
}

sub make_chapter_pod($$)
{   my ($file, $chapter) = @_;
    return unless defined $chapter;

    $file->print("\n=head1 $chapter->{title}\n\n");
    $file->print(text_cleanup $chapter->{text});

    foreach my $section (@{$chapter->{sections}})
    {   $file->print("\n=head2 $section->{title}\n\n");
        $file->print(text_cleanup $section->{text});
    }
}

sub make_chapter_html($$$)
{   my ($file, $filename, $chapter) = @_;
    return '' unless defined $chapter;

    my $title = ucfirst lc $chapter->{title};
    my $label = $title;
    $label    =~ s/\s+/_/g;

    $file->print( qq[\n<h2 name="#$label">$title</h2>\n\n] );
    my $index = qq[<li><a href="doc.html#$label" target="main">$title</a>];

    my $text  = make_text_html $filename, $chapter->{text};
    $file->print($text);

    while($text =~ m#\<h3.*?\><a name="([^"]*)"\>(.*?)\</a\>\</h3\>#g)
    {   $index  .= qq[<br />
    &middot;&nbsp;<a href="doc.html#$1" target="main">$2</a>];
    }

    my @sections = @{$chapter->{sections}};

    foreach my $section (@sections)
    {   my $sectitle = ucfirst lc $section->{title};
        $label   = $sectitle;
        $label   =~ s/\s+/_/g;

        $file->print( qq[\n<h3 name="$label">$sectitle</h3>\n\n] );
        $index  .= qq[<br />
     &middot;&nbsp;<a href="doc.html#$label" target="main">$sectitle</a>];

        $file->print(make_text_html $filename, $section->{text});
    }

    $index .= "</li>\n";
    $index;
}

sub all_super_classes($);
sub all_super_classes($)
{   my $package = shift;
    my $pkg     = $pkgs{$package};
    my $extends = $pkg->{realizes} || $pkg->{extends};
    $extends ? ($package, all_super_classes $extends) : ($package);
}

sub all_super_manuals($)
{   my $package = shift;

    map { $_->{manual} }
       map { @{$pkgs{$_}{pods}} }
          ($package, all_super_classes $package);
}

sub collect_methods_per_section(@)
{   my %sections;

    foreach my $name (sort keys %methods)
    {   my $method;
        foreach my $super (@_)
        {   $method = (grep {$_->{manual} eq $super} @{$methods{$name}})[0];
            last if $method;
        }

        next unless defined $method;

        my $section = $method->{section};
        push @{$sections{$section}}, $method;
    }

    \%sections;
}

sub method_for_super($$)
{   my ($name, $super) = @_;
    first {$_->{manual} eq $super} @{$methods{$name}};
}

sub take_options($$)
{   my ($options, $method) = @_;
    my %options;

    $options->{$_->{name}} = { %$_ }
        foreach @{$method->{options}};
}

sub take_defaults($$)
{   my ($options, $method) = @_;

    foreach my $def (@{$method->{defaults}})
    {   my $name     = $def->{option};

        unless(exists $options->{$name})
        {   warn "WARNING: $def->{manual} method $method->{name}: "
               . "default for unknown option $name.\n";
            next;
        }

        $options->{$name}{default} = $def->{value};
    }
}

sub make_methods_pod($$$)
{   my ($file, $pod, $chapter) = @_;
    return unless defined $chapter;

    my $package = $pod->{package};
    my $manual  = $pod->{manual};

    warn "ERROR: No title for chapter in $manual.\n"
        unless defined $chapter->{title};

    $file->print("\n=head1 $chapter->{title}\n");
    $file->print(text_cleanup $chapter->{text});

    my @supers   = all_super_manuals $package;
    my $sections = collect_methods_per_section @supers;

    foreach my $section (ordered_sections keys %$sections)
    { $file->print("\n=head2 $section\n\n=over 4\n");

      foreach my $method ( @{$sections->{$section}} )
      { my $name = $method->{name};

        if($manual eq $method->{manual})
        {   $file->print("\n=item B<$name> $method->{usage}\n");

            my $type
             = $method->{type} eq 'ci_' ? "(Class or Instance method) "
             : $method->{type} eq 'c_'  ? "(Class method) "
             : $method->{type} eq 'no_' ? "(not a method) "
             : '';

            $file->print(make_text_pod($type.$method->{descr}));

            my %options;
            foreach my $super (reverse @supers)
            {   my $def = method_for_super $name, $super;
                next unless $def && ref $def->{defaults};

                take_options  \%options, $def;
        	take_defaults \%options, $def;
            }

            if(keys %options)
            {   $file->print("\n OPTION               DEFAULT\n");
                foreach (sort keys %options)
                {   my $option = $options{$_};
                    warn "option $option->{name} has no default.\n"
                        unless defined $option->{default};
                    $file->printf(" %-20s $option->{default}\n", $option->{name});
                }

                $file->print("\n=over 4\n");

                foreach (sort keys %options)
                {   my $option = $options{$_};
                    if($option->{manual} eq $manual)
                    {   my $label  = "$name($_)";
                        $file->print("\n=item B<$_> =E<gt> $option->{usage}\n");
                        $file->print(text_cleanup $option->{descr});
                    }
                    else
                    {   $file->print("\n=item B<$_> =E<gt> $option->{usage}\n");
                        my $where = $option->{manual};
                        $file->print("\nSee ${where}::$name($_)\n");
                    }
                }
                $file->print("\n=back\n");
            }

            my $examples = $method->{examples};
            if(defined $examples && length $examples)
            {    $file->print("\nExamples:\n");
                 $file->print(make_text_pod $examples);
            }
        }
        else
        {   my $mm = $method->{manual};
            $file->print("\n=item B<$name> $method->{usage}\n\n");
            $file->print("See ${mm}::$name()\n");
        }
      }
      $file->print("\n=back\n");
    }
}

sub see_also_pod($)
{   my $file = shift;
    $file->print( <<SEE_ALSO );

=head1 SEE ALSO

A good start to read is Mail::Box-Overview.
More documentation and a mailinglist are available from the project's
website at L<$website>.
SEE_ALSO
}

sub written_by($)
{   my $package = shift;

      $package =~ m!POP!  ? ( $liz, $markov )
    : $package =~ m!Exim! ? ( $greg, $markov )
    :                       ( $markov );
}

sub author_pod($$)
{   my ($file, $package) = @_;

    my @by = written_by($package);
    my $by = join ' and ', map { "$_->[0] (L<$_->[1]|mailto:$_->[1]>)" } @by;
    $file->print( <<AUTHOR );

=head1 AUTHOR

Written by $by
with the help of many.  See the ChangeLog for details.
AUTHOR
}

sub author_html($$)
{   my ($file, $package) = @_;

    my @by = written_by($package);
    my $by = join ' and ', map { "<a href=\"mailto:$_->[1]\">$_->[0]</a>" } @by;

    my $auth = @by==1 ? 'Author' : 'Authors';

    $file->print( <<AUTHOR );
<h2 name="authors">$auth</h2>

<p>Written by $by
with the help of many.
For support, look at the central <a href="$website">website</a> or contact the
<a href="mailto:$mailinglist">mailing list</a>.
See the <a href="$url_coderoot/ChangeLog" target="_blank">ChangeLog</a>
for details.</p>
AUTHOR

    qq[<li><a href="doc.html#authors" target="main">$auth</a></li>\n];
}

sub version_pod($)
{   my $file = shift;

    $file->print( <<VERSION );

=head1 VERSION

This code is beta, version $version.

Copyright (c) 2001-2003 by the authors. All rights reserved.
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
VERSION
}

sub version_html($)
{   my $file = shift;

    $file->print( <<VERSION );
<h2 name="version">Copyrights</h2>

<p>This code is beta, version $version.<br />
&copy;&nbsp;2001-2003 by the authors. All rights reserved.
This program is free software; you can redistribute it and/or modify
it under the same <a href="$url_coderoot/LICENCE">terms as Perl</a>
itself.</p>
VERSION

   qq[<li><a href="doc.html#$version" target="main">Copyrights</a></li>\n];
}

sub manual_to_pod($)
{   my $pod      = shift;
    my $filename = $pod->{podfile};
    my $package  = $pod->{package};

    my $file = IO::File->new($filename, "w")
       or die "Cannot write pod to file $filename: $!\n";

    my %chapter  = map { ($_->{title} => $_) } @{$pod->{chapters}};

    make_chapter_pod   $file, delete $chapter{NAME};
    inheritance_to_pod $file, $pod->{package};
    make_chapter_pod   $file, delete $chapter{SYNOPSIS};
    make_chapter_pod   $file, delete $chapter{DESCRIPTION};
    make_methods_pod   $file, $pod, delete $chapter{METHODS};
    make_chapter_pod   $file, delete $chapter{IMPLEMENTATION}
       if defined $chapter{IMPLEMENTATION};

    see_also_pod $file;
    author_pod  $file, $package;
    version_pod $file;

    my @unused = sort keys %chapter;
    warn "WARNING $filename: unused chapters @unused.\n"
        if @unused;
}

sub start_html_file($$)
{   my ($filename, $title) = @_;

    my $css  = link_to($filename, $url_css);
    my $file = IO::File->new($filename, "w");

    $file->print( <<HEAD );
<html>
<head>
   <title>$title</title>
   <link rel="STYLESHEET" type="text/css" href="$css">
</head>
HEAD

    $file;
}

sub create_html_head($$$)
{   my ($filename, $title, $subtitle) = @_;
    my $file    = start_html_file $filename, "$title $subtitle";

    my $doclink = link_to $filename, "$html_root/index.html";
    my $pkglink = link_to $filename, "$html_root/packages/index.html";
    my $metlink = link_to $filename, "$html_root/methods/index.html";
    my $dialink = link_to $filename, "$html_root/diagnostics/index.html";

    $file->print( <<HEAD );
<table width="100%">
<tr><td valign="top">
       <b>Mail::Box software</b><br />
       <a href="$doclink" target="_top">Documentation</a><br />
    </td><td align="center" valign="bottom">
       <h1>$title<br /><font size="5">$subtitle</font></h1>
    </td><td valign="top">
       <a href="$pkglink" target="_top">all packages</a><br />
       <a href="$metlink" target="_top">all methods</a><br />
       <a href="$dialink" target="_top">all diagnostics</a><br />
    </td></tr>
</table>

</body>
</html>
HEAD

     $file->close;
}

sub manual_html_doc($$$)
{   my ($pod, $htmldir, $htmlurl) = @_;
    my $package = $pod->{package};
    my $filename= "$htmldir/doc.html";
    my $file    = start_html_file $filename, $package;

    my %chapter = map { ($_->{title} => $_) } @{$pod->{chapters}};
    my $index   = qq[<ul class="head1">\n];
    $index     .= make_chapter_html $file, $filename, $chapter{NAME};
    $index     .= make_chapter_html $file, $filename, $chapter{SYNOPSIS};
    $index     .= make_chapter_html $file, $filename, $chapter{DESCRIPTION};
    $index     .= make_chapter_html $file, $filename, $chapter{IMPLEMENTATION}
       if defined $chapter{IMPLEMENTATION};
    $index     .= author_html $file, $package;
    $index     .= version_html $file;

    $index     .= qq[</ul>\n];

    $file->print( <<BODY );
</body>
</html>
BODY

    $file->close;
    $index;
}

sub manual_html_index($$$)
{   my ($pod, $htmldir, $htmlurl) = @_;

    my $package = $pod->{package};
    my $file  = start_html_file "$htmldir/index.html", $package;

    $file->print( <<INDEX );

<frameset rows="130,*" frameborder="NO">
   <frame src="head.html" name="head">
   <frameset cols="225,*,225" frameborder="NO">
      <frame src="class.html"   name="class">
      <frame src="doc.html"     name="main">
      <frame src="methods.html" name="nav">
   </frameset>
<frameset>

</html>
INDEX

    $file->close;
}

sub manual_html_head($$)
{   my ($pod, $htmldir) = @_;
    my $package  = $pod->{package};
    my $filename = "$htmldir/head.html";

    my $name    = first { $_->{title} eq 'NAME' } @{$pod->{chapters}};
    my $descr   = make_text_html $filename, $name->{text};
    $descr      =~ s/.*\-\s*//;

    create_html_head $filename, $package, $descr;
}

sub manual_html_class($$$$)
{   my ($pod, $htmldir, $sections, $index) = @_;
    my $package  = $pod->{package};
    my $filename = "$htmldir/class.html";
    my $file     = start_html_file $filename, $package;

    $file->print( "<body>\n\n" );

    inheritance_to_html $file, $filename, $package;

    $file->print( <<BODY );
&nbsp;<br />
<b>General docs:</b>
$index

<b>Method sections:</b>
<ul class="methgroups">
BODY

   foreach my $secname (ordered_sections keys %$sections)
   {   my $link = lc $secname;
       $link    =~ s/\W+/_/g;
       my $nr   = @{$sections->{$secname}};
       $file->print(
         qq[<li><a href="$link.html" target="main">$secname</a>&nbsp;($nr)</li>\n]
                    );
   }

   $file->print( <<TAIL );
</ul>

</body>
</html>
TAIL

    $file->close;
}

sub html_method_links($@)
{   my $seclink = shift;
    my @links;
    foreach my $method (@_)
    {   my $methlink = "$seclink#$method->{name}";
        push @links, qq[<a href="$methlink" target="main">$method->{name}</a>];
    }
    @links;
}

sub manual_html_methods_per_section($$$)
{   my ($pod, $htmldir, $sections) = @_;
    my $package = $pod->{package};
    my $file    = start_html_file "$htmldir/methods_ps.html", $package;

    $file->print( <<HEAD );
<body>

<ul>
<li><a href="methods.html">unsorted</a> methods
<li>methods <b>per section</b>
</ul>
HEAD

    $file->print( qq[<div class="methods_ps">\n] );
    foreach my $secname (ordered_sections keys %$sections)
    {   my $seclink = lc $secname;
        $seclink    =~ s/\W+/_/g;
        $seclink   .= '.html';
        $file->print( qq[<b>$secname:</b>\n] );

        my @methlinks = html_method_links $seclink, @{$sections->{$secname}};
        local $" = ",\n   ";
        $file->print( qq[@methlinks<br />\n] );
    }

    $file->print( <<BODY );
</div>

</body>
</html>
BODY

    $file->close;
}

sub manual_html_all_methods($$$)
{   my ($pod, $htmldir, $sections) = @_;
    my $package = $pod->{package};

    my $file    = start_html_file "$htmldir/methods.html", $package;

    $file->print( <<HEAD );
<body>

<ul>
<li><b>unsorted</b> methods
<li>methods <a href="methods_ps.html">per section</a>
</ul>
HEAD

    my @methods;
    foreach my $secname (keys %$sections)
    {   my $seclink = lc $secname;
        $seclink    =~ s/\W+/_/g;
        $seclink   .= '.html';

        push @methods, [ $_->{name}, html_method_links($seclink, $_) ]
            foreach @{$sections->{$secname}};
    }

    my @methlinks   = map { $_->[1] } sort { lc($a->[0]) cmp lc($b->[0]) } @methods;
    local $" = ",\n    ";
    $file->print( qq[@methlinks\n] );

    $file->print( <<BODY );
</body>
</html>
BODY

    $file->close;
}

sub manual_html_method_options($$$$)
{   my ($file, $filename, $pod, $options) = @_;
    return unless keys %$options;

    my $manual   = $pod->{manual};

    $file->print( qq[&middot;&nbsp;options<br />\n] );

    $file->print( <<'TABLE_HEAD' );
<table border="0" cellpadding="0" cellspacing="0">
<tr><td>&nbsp;&nbsp;&nbsp;</td>
    <th align="left">option&nbsp;&nbsp;</td><td>&nbsp;&nbsp;&nbsp;</td>
    <th align="left">default&nbsp;&nbsp;</td><td>&nbsp;&nbsp;&nbsp;</td>
    <th align="left">provided by</td>
TABLE_HEAD

    foreach (sort keys %$options)
    {   my $option = $options->{$_};
        warn "option $option->{name} has no default.\n"
            unless defined $option->{default};

        my $other_manual
            = $option->{manual} eq $manual ? ''
            : make_text_html $filename, $option->{manual};

        my $default = make_text_html $filename, $option->{default};

        $file->print( <<OPTION );
<tr><td/&nbsp;</td>
    <td>$option->{name}</td><td></td>
    <td>$default</td><td></td>
    <td>$other_manual</td></tr>
OPTION
    }

    $file->print( <<'TABLE' );
</table>
&nbsp;<br>
TABLE

    $file->print( qq[<dl class="options">\n] );

    foreach (sort keys %$options)
    {   my $option = $options->{$_};
        my $where  = $option->{manual} eq $manual ? ''
                   : ' (any '.href_to_pkg($filename, $option->{manual}).')';

        $file->print( qq[<dt><code>$_ =&gt; $option->{usage}</code>$where</dt>\n] );
        $file->print("<dd>".make_text_html($filename, $option->{descr})."</dd>\n");
    }

    $file->print( qq[</dl>\n] );
    $file->print( qq[</dd><dd>\n] );  # left-margin bug in Mozilla work-around
}

sub manual_html_section($$$$$)
{   my ($pod, $htmldir, $secname, $supers, $methods) = @_;
    my $package  = $pod->{package};

    my $seclink  = lc $secname;
    $seclink     =~ s/\W+/_/g;
    $seclink    .= '.html';

    my $filename = "$htmldir/$seclink";
    my $file     = start_html_file $filename, "$package; $secname";

    $file->print( <<HEAD );
<body>

<h1>$package<br /><font size="5">$secname</font></h1>
HEAD

    foreach my $method ( @$methods )
    {   my $name = $method->{name};
        $file->print( qq[<a href="#$name">$name</a> $method->{usage}<br />\n] );
    }

    $file->print( qq[<dl class="methlist">\n] );
    foreach my $method ( @$methods )
    {   my $name  = $method->{name};
        my $type  = $method->{type};
        my $nname = qq[<a name="$name">$name</a>];
        my $usage = $method->{usage};
    
        if($type eq 'no_')
        {   $file->print( "<dt><b>$nname(</b> $usage <b>)</b></dt>\n" );
        }
        elsif($type eq 'i_')
        {   $file->print( "<dt><b>\$obj-&gt;$nname(</b> $usage <b>)</b></dt>\n" );
        }
        elsif($type eq 'c_')
        {   $file->print( "<dt><b>$package-&gt;$nname(</b> $usage <b>)</b></dt>\n");
        }
        else  # $type eq 'ci_'
        {   $file->print( "<dt><b>$package-&gt;$name(</b> $usage <b>)</b><br />\n");
            $file->print( "    <b>\$obj-&gt;$nname(</b> $usage <b>)</b></dt>\n" );
        }

        $file->print("<dd>", make_text_html $filename, $method->{descr});

        my %options;
        foreach my $super (reverse @$supers)
        {   my $def = method_for_super $name, $super;
            next unless $def && ref $def->{defaults};

            take_options  \%options, $def;
	    take_defaults \%options, $def;
        }

        manual_html_method_options $file, $filename, $pod, \%options;

        my $examples = $method->{examples};
        if(defined $examples && length $examples)
        {    $file->print("&middot;&nbsp;examples<br />\n");
             $file->print(make_text_html $filename, $examples);
        }

        if(exists $method->{reports})
        {   $file->print( qq[&middot;&nbsp;diagnostics<br />\n] );
            $file->print( qq[<dl class="reports">\n] );

            foreach my $report ( @{$method->{reports}} )
            {   my ($level, $message, $descr) = @$report;
                $file->print( qq[<dt class="$level">$level: $message</dt>\n] );
                $file->print( qq[<dd class="${level}_descr">],
                     make_text_html($filename, $descr), qq[</dd>\n] );
            }

            $file->print( qq[</dl>\n] );
        }
    }

    $file->print( <<TAIL );
    </dl>
</body>
</html>
TAIL

    $file->close;
}

sub manual_to_html($)
{   my $pod      = shift;
    my $htmldir  = $pod->{htmldir};
    my $htmlurl  = $pod->{htmlurl};
    my $package  = $pod->{package};

    my @supers   = all_super_manuals $package;
    my $sections = collect_methods_per_section @supers;

    manual_html_index               $pod, $htmldir, $htmlurl;
    my $index    = manual_html_doc  $pod, $htmldir, $htmlurl;
    manual_html_head                $pod, $htmldir;
    manual_html_class               $pod, $htmldir, $sections, $index;
    manual_html_methods_per_section $pod, $htmldir, $sections;
    manual_html_all_methods         $pod, $htmldir, $sections;

    manual_html_section             $pod, $htmldir, $_, \@supers, $sections->{$_}
       foreach keys %$sections;
}

sub manual_package_list_html($)
{   my $manuals = shift;

    my $settop = "$html_root/packages";
    mkdirhier $settop;
    my $file   = start_html_file "$settop/index.html", "Mail::Box packages index";

    $file->print( <<FRAMESET );
<frameset rows="150,*" frameborder="NO">
   <frame src="head.html" name="head">
   <frame src="main.html" name="main">
</frameset>

</html>
FRAMESET

    $file->close;

    my $headfile = "$settop/head.html";
    create_html_head $headfile, "Mail::Box",  "Package index";

    $file = start_html_file "$settop/main.html", "Mail::Box packages";

    $file->print( "<body>\n" );

    my @packages = unique map {$_->{package}} @$manuals;
    my @links = map { href_to_pkg($headfile, $_) } sort @packages;
    my $l     = int( (@links+2)/3 );

    local $"  = "<br />\n    ";
    my @left  = @links[0..($l-1)];
    my @middle= @links[$l..(2*$l-1)];
    my @right = @links[(2*$l)..$#links];

    $file->print( <<TABLE );
<center>
<table>
<tr><td valign="top">
    @left
</td><td valign="top">
    @middle
</td><td valign="top">
    @right
</td></tr>
</table>
</center>
TABLE

    $file->print( <<TAIL );

</body>
</html>
TAIL

    warn @links." packages listed\n";
}

sub manual_method_list_html($)
{   my $pods   = shift;

    my $settop = "$html_root/methods";
    mkdirhier $settop;
    my $file   = start_html_file "$settop/index.html", "Mail::Box methods index";

    $file->print( <<FRAMESET );
<frameset rows="150,*" frameborder="NO">
   <frame src="head.html" name="head">
   <frameset cols="40,300,*" frameborder="NO">
       <frame src="alpha.html" name="alpha">
       <frame src="A.html"     name="list">
       <frame src=""           name="main">
   </frameset>
</frameset>

</html>
FRAMESET

    $file->close;

    create_html_head "$settop/head.html", "Mail::Box",  "Methods index";

    my @methods = map { @{$methods{$_}} }
       sort {lc($a) cmp lc($b)} keys %methods;

    my %links;
    foreach my $method (@methods)
    {   my ($name, $manual, $section) = @$method{ qw/name manual section/ };
        $section =~ s/\W+/_/g;
        $section = (lc $section) . '.html';
        my $pod  = $pods{$manual};


        $manual =~ s/^Mail::Message::/MM::/;
        $manual =~ s/^Mail::Box::/MB::/;
        $manual =~ s/^Mail::Transport::/MT::/;

        my $char = uc(substr $name, 0, 1);
        my $page = "$html_root/methods/$char.html";
        my $link = qq[<a href="]
                 . link_to($page, "$pod->{htmldir}/$section#$name")
                 . qq[" target="main">$name</a>];

        push @{$links{$char}}, qq[$link\n <font size="2">$manual</font>];
    }

    my $alpha   = start_html_file "$html_root/methods/alpha.html", "methods alpha";
    my $nrlinks = 0;

    foreach my $char ('A'..'Z')
    {   my $links = delete $links{$char};

        unless($links)
        {   # $alpha->print("$char<br />\n");
            next;
        }

        $nrlinks += @$links;
        $alpha->print( qq[<a href="$char.html" target="list">$char</a><br />\n] );

        my $charfile = start_html_file "$html_root/methods/$char.html",
                                       "methods $char";

        local $" = "<br />\n";
        $charfile->print( <<PAGE );
<body>
<p>Abbreviations:<br />
MB&nbsp;=&nbsp;Mail::Box,<br />
MM&nbsp;=&nbsp;Mail::Message,<br />
MT&nbsp;=&nbsp;Mail::Transfer</p>

@$links

</body>
</html>
PAGE

        $charfile->close;
    }

    $alpha->close;
    die "Methods left" if keys %links;

    warn "$nrlinks methods listed\n";
}

sub manual_diag_list_html($)
{   my $pods = shift;

    my $settop = "$html_root/diagnostics";
    mkdirhier $settop;
    my $file = start_html_file "$settop/index.html", "Mail::Box diagnostics index";

    $file->print( <<FRAMESET );
<frameset rows="150,*" frameborder="NO">
   <frame src="head.html" name="head">
   <frame src="main.html" name="main">
</frameset>

</html>
FRAMESET

    $file->close;

    create_html_head "$settop/head.html", "Mail::Box",  "diagnostics index";

    my $filename = "$html_root/diagnostics/main.html";
    $file = start_html_file $filename, "Mail::Box diagnostics";

    $file->print( "\n<body>\n<dl>\n" );

    my @methods = map { @{$methods{$_}} }
       sort {lc($a) cmp lc($b)} keys %methods;

    my @list;
    foreach my $method (@methods)
    {   next unless exists $method->{reports};
        my @diags = @{$method->{reports}};

        my ($name, $manual, $section) = @$method{ qw/name manual section/ };
        $section =~ s/\W+/_/g;
        $section = lc $section;
        my $pod  = $pods{$manual};
        my $url  = $pod->{htmldir};

        my $podlink  = qq[<a href="] . link_to($filename,"$url/index.html")
                     . qq[" target="_top">$manual</a>];

        my $methlink = qq[<a href="] . link_to($filename,"$url/$section.html#$name")
                     . qq[">$name</a>()];

        foreach my $diag (@diags)
        {   my ($level, $msg, $descr) = @$diag;
            my $err  = "<b>$msg</b>";
            my $fail = $level eq 'error' ? "Error message" : ucfirst($level);
            my $dt   = "$err<br />\n    $fail in $podlink method $methlink\n";

            push @list, [ lc($msg), $dt, $descr ];
        }
    }

    foreach my $diag (sort {$a->[0] cmp $b->[0]} @list)
    {   $file->print( "<dt>$diag->[1]</dt>\n<dd>"
                    , make_text_html($filename, $diag->[2])
                    , "</dd>\n\n"
                    );
    }

    $file->print( <<TAIL );
</dl>

</body>
</html>
TAIL

    warn @list." diagnostics listed\n";
}

sub create_all_docs()
{
   my @pods = values %pods;
   foreach my $pod (@pods)
   {   print "Producing docs for $pod->{package}.\n" if $verbose;
       manual_to_pod  $pod;
       manual_to_html $pod;
   }

   print "Producing package list.\n" if $verbose;
   manual_package_list_html \@pods;

   print "Producing method list.\n" if $verbose;
   manual_method_list_html  \@pods;

   print "Producing diagnostics list.\n" if $verbose;
   manual_diag_list_html  \@pods;
}

###
### MAIN
###

mkdirhier $workdir;

#
## Scan files for data
## static files are already copied.
#

foreach my $filename (manifest)
{
    die "Cannot find file $filename from MANIFEST.\n"
       unless -f $filename;

    my $becomes = File::Spec->catfile($workdir, $filename);
    my $outdir  = dirname $becomes;
    mkdirhier $outdir;

    if( $filename =~ m/\.(pm|pod)$/ && $filename !~ m!^tests/! )
    {   # All package files are split in a pod and a code file
        strip_pod $filename, $becomes;
        my $pod          = absorb_pod $filename;
        my $package      = $pod->{package};
        push @{$pkgs{$package}{pods}}, $pod;
        $pods{$pod->{manual}}  = $pod;

        if($filename =~ m/\.pm$/)
        {   my %info         = get_compile_info $package, $filename;
            @$pod{ keys %info } = values %info;
        }

        # POD locations
        $becomes         =~ s/\.pm$/.pod/;
        $pod->{podfile}  = $becomes;

        # HTML locations
        (my $base        = $filename) =~ s/\.(pm|pod)$//;
        $pod->{htmlurl}  = "$url_htmlroot/$base";
        my $htmldir      = "$html_root/$base";
        $pod->{htmldir}  = $htmldir;

        mkdirhier $htmldir;

    }
    elsif(-f $becomes && -M $becomes < -M $filename)
    {   # None PM files are only copied if changed
        print "$filename still same as $becomes; skipped\n"
           if $verbose;
    }
    else
    {   copy $filename, $becomes
           or die "Cannot copy $filename to $becomes: $!\n";

        print "$filename simply copied to $becomes.\n"
           if $verbose;
    }
}

#dump_pkg_structure;

#
## Prepare before generating
#

foreach my $package (sort keys %pkgs)
{   cleanup_package_relations $package;
}

build_method_index;

#
## Create the dynamic pages
#

create_all_docs;
